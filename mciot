;1.Use Labels to calculate the sum of say 10 numbers.
;additon 32 bit
PRESERVE8 ; Indicate the code here preserve
; 8 byte stack alignment
THUMB ; Indicate THUMB code is used
AREA |.text|, CODE, READONLY
EXPORT __main
; Start of CODE area
DataIn EQU 0x20000000
Sum EQU 0x20000040
__main
LDR r0,=DataIn; Get the address of variable 'DataIn'
MOVS r1, #10 ; loop counter
MOVS r2, #0 ; Result - starting from 0
add_loop
LDM r0!,{r3} ; Load result and increment address
ADDS r2, r3 ; add to result
SUBS r1, #1 ; increment loop counter
BNE add_loop
LDR r0,=Sum ; Get the address of variable 'Sum'
STR r2,[r0] ; Save result to Sum
stop B stop
END
=================================================================================
;2.Write an Assembly level program to copy multiple data at a time say 128 bytes of data in two iteration
;additon 32 bit
PRESERVE8 ; Indicate the code here preserve
; 8 byte stack alignment
THUMB ; Indicate THUMB code is used
AREA |.text|, CODE, READONLY
EXPORT __main
; Start of CODE area
__main
LDR r0,=0x20000000 ; Source address
LDR r1,=0x20000120 ; Destination address
LDR r2,=128 ; number of bytes to copy, also
copy_loop ; acts as loop counter
LDMIA r0!,{r4-r7} ; Read 4 words and increment r0
STMIA r1!,{r4-r7} ; Store 4 words and increment r1
LDMIA r0!,{r4-r7} ; Read 4 words and increment r0
STMIA r1!,{r4-r7} ; Store 4 words and increment r1
LDMIA r0!,{r4-r7} ; Read 4 words and increment r0
STMIA r1!,{r4-r7} ; Store 4 words and increment r1
LDMIA r0!,{r4-r7} ; Read 4 words and increment r0
STMIA r1!,{r4-r7} ; Store 4 words and increment r1
SUBS r2, r2, #64 ; Each time 64 bytes are copied
BNE copy_loop ; loop until all data copied
stop B stop
END
===================================================================================
;3.Write a program to illustrate ASR and LSLS instruction.
PRESERVE8 ; Ensure 8-byte stack alignment
THUMB ; Use THUMB instruction set
AREA |.text|, CODE, READONLY
EXPORT __main
__main
LDR r0, =0xF0000000 ; Load a negative number in R0 (signed)
ASRS r1, r0, #4 ; Arithmetic Shift Right by 4 bits
; Preserves the sign (0xFF000000 if signed)
LDR r2, =0x0000000F ; Load small positive value in R2
LSLS r3, r2, #2 ; Logical Shift Left by 2 bits
stop B stop
END
===================================================================================
;4.Write a program to illustrate the processing of data in a stack and realizing of stack using another file say (processing x to read 2x+9).
;Main.asm
PRESERVE8 ; Indicate the code here preserve
; 8 byte stack alignment
THUMB ; Indicate THUMB code is used
AREA |.text|, CODE, READONLY
EXPORT __main
EXTERN func
; Start of CODE area
__main
LDR r0,=0x10;
BL func
stop B stop
END
------------------------------------------
PRESERVE8
THUMB
AREA |.text|, CODE, READONLY
EXPORT func
func
push{r0}
MOVS r1,#02
MULS r0,r1,r0
adds r0,r0,#9
BX LR
END
========================================================================
;5.Write a program to clear and extract the bits with starting position P and width of the bits W.
PRESERVE8 ; Indicate the code here preserve
; 8 byte stack alignment
THUMB ; Indicate THUMB code is used
AREA |.text|, CODE, READONLY
EXPORT __main
; Start of CODE area
__main
;extracting
LDR r0,=0xFFC0FFFF
LSLS r0,r0,#(32-16-8)//(32-W-P)
LSRS r0,r0,#(32-8)
;clearing
LDR r0,=0xFFC0FFFF
MOVS r1,#16
MOVS R2,#08;(32-16-08)//( 32-W-P)
MOVS r3,#08
RORS r0,r0,r1
LSRS r0,r0,r2
RORS r0,r0,r3
stop B stop
END
===========================================================================
;6.Write a program to use switch case.
PRESERVE8 ; Indicate the code here preserve
; 8 byte stack alignment
THUMB ; Indicate THUMB code is used
AREA |.text|, CODE, READONLY
EXPORT __main
; Start of CODE area
__main
LDR R0, =0
CMP R0, #3 ; Compare input to maximum valid choice
BHI default_case ; Branch to default case if higher than 3
MOVS R2, #4 ; Multiply branch table offset by 4
MULS R0, R2, R0 ; (size of each entry)
LDR R1, =BranchTable ; Get base address of branch table(0x284)
LDR R2,[R1,R0] ; Get the actual branch destination
BX R2 ; Branch to destination
ALIGN 4 ; Alignment control. The table has
BranchTable ; to be word aligned to prevent unaligned read ;table of each destination address
DCD Dest0
DCD Dest1
DCD Dest2
DCD Dest3
default_case
stop B stop; Instructions for default case
Dest0 ldr r0, =10
stop1 B stop1 ; Instructions for case ‘0’
Dest1 ldr r0, =20
stop2 B stop2 ; Instructions for case ‘1’
Dest2 ldr r0, =30
stop3 B stop3 ; Instructions for case ‘2’
Dest3 ldr r0, =40
stop4 B stop4 ; Instructions for case ‘3’
END
================================================================================
//7.Write a C program to Light LEDs connected to port C12-15 using macros.
// Smpl_GPIO_LED1 : GPC12--15 GPA 12_14 to control on-board LEDs
// low-active output to control Red LEDs
//
#include <stdio.h>
#include "NUC1xx.h"
#include "Driver\DrvGPIO.h"
#include "Driver\DrvSYS.h"
void Init_LED() // Initialize GPIO pins
{
DrvGPIO_Open(E_GPC, 12, E_IO_OUTPUT); // GPC12 pin set to output mode
DrvGPIO_SetBit(E_GPC, 12); // Goutput Hi to turn off LED
}
int main (void)
{
UNLOCKREG(); // unlock register for programming
DrvSYS_Open(48000000);// set System Clock to run at 48MHz
// 12MHz crystal input, PLL output 48MHz
LOCKREG(); // lock register from programming
Init_LED(); // Initialize LEDs (four on-board LEDs below LCD panel)
while (1) // forever loop to keep flashing four LEDs one at a time
{
DrvGPIO_ClrBit(E_GPC, 12); // output Low to turn on LED
DrvSYS_Delay(300000); // delay
DrvGPIO_SetBit(E_GPC, 12); // output Hi to turn off LED
DrvSYS_Delay(300000); // delay
}
}
====================================================================================
//8.Write a C program to display 4 lines of Text on LCD.
// Smpl_LCD_Text: display 4 lines of Text on LCD
//
#include <stdio.h>
#include "NUC1xx.h"
#include "Driver\DrvSYS.h"
#include "Driver\DrvGPIO.h"
#include "NUC1xx-LB_002\LCD_Driver.h"
int main(void)
{
UNLOCKREG();
DrvSYS_Open(48000000); // set to 48MHz
LOCKREG();
Initial_panel();
clr_all_panel();
print_lcd(0, "Smpl_LCD_Text ");
print_lcd(1, "Nu-LB-NUC140 ");
print_lcd(2, "Test LCD Display");
print_lcd(3, "Nuvoton NuMicro ");
}
====================================================================================
//9.Write a C program to enable External Interrupt pin to trigger interrupt on GPB15 and buzz.
// Smpl_GPIO_EINT1 : External Interrupt pin to trigger interrupt on GPB15, then Buzz
//
#include <stdio.h>
#include "NUC1xx.h"
#include "Driver\DrvGPIO.h"
#include "Driver\DrvUART.h"
#include "Driver\DrvSYS.h"

// Interrupt handler: called when button on GPB15 is pressed
void EINT1_Handler(void) {
    GPIOB->ISRC = (1 << 15);       // Clear interrupt flag
    DrvGPIO_ClrBit(E_GPB, 11);     // Buzzer ON (active low)
    DrvSYS_Delay(100000);          // Small delay
    DrvGPIO_SetBit(E_GPB, 11);     // Buzzer OFF
}

int main(void) {
    // Setup system clock
    UNLOCKREG();
    DrvSYS_SetOscCtrl(E_SYS_XTL12M, 1);  // Enable 12MHz crystal
    DrvSYS_Delay(5000);                  // Wait for stabilization
    DrvSYS_SelectHCLKSource(0);          // Select external crystal for HCLK
    LOCKREG();

    // Setup buzzer pin (GPB11) as output
    DrvGPIO_Open(E_GPB, 11, E_IO_OUTPUT);
    DrvGPIO_SetBit(E_GPB, 11);  // Turn buzzer OFF initially

    // Setup external interrupt on GPB15
    DrvGPIO_Open(E_GPB, 15, E_IO_INPUT);  // GPB15 as input
    DrvGPIO_EnableEINT1(E_IO_BOTH_EDGE, E_MODE_EDGE, EINT1_Handler);  // Trigger on both edges

    while (1) {
        // Do nothing, wait for interrupt
    }
}

========================================================================================
//10.Write a C program to take input from 3x3 keypad and output to LCD display.
#include <stdio.h>
#include "NUC1xx.h"
#include "DrvSYS.h"
#include "DrvGPIO.h"
#include "scankey.h"
#include "NUC1xx-LB_002/LCD_Driver.h"

int32_t main(void)
{
    int8_t key;
    char title[16] = "Smpl_LCD_Keypad";
    char line[16];

    // Unlock protected registers
    UNLOCKREG();
    DrvSYS_Open(48000000);  // Set system clock to 48 MHz
    LOCKREG();

    Initial_panel();        // Initialize LCD
    clr_all_panel();        // Clear LCD display
    OpenKeyPad();           // Initialize 3x3 keypad

    print_lcd(0, title);    // Show title on first line

    while (1)
    {
        key = Scankey();   // Read key input

        if (key != 0)      // If any key is pressed
        {
            sprintf(line, "Keypad: %d", key);  // Prepare message
            print_lcd(1, line);                // Show on LCD line 1
        }

        DrvSYS_Delay(5000); // Small delay to avoid flicker
    }
}


=============================================================================================================
//11.Write a C program to count from 0 to 99 and display them on 7-segment LEDs.
#include <stdio.h>
#include "NUC1xx.h"
#include "Driver\DrvSYS.h"
#include "Seven_Segment.h"
#include "DrvGPIO.h"
#include "DrvSYS.h"

void seg_display(int16_t value)
{
    int8_t digit;

    digit = value / 10;
    close_seven_segment();
    show_seven_segment(1, digit);
    DrvSYS_Delay(5000);

    digit = value % 10;
    close_seven_segment();
    show_seven_segment(0, digit);
    DrvSYS_Delay(5000);
}

int32_t main(void)
{
    int val = 0;

    UNLOCKREG();
    DrvSYS_Open(48000000);  // Set system clock to 48 MHz
    LOCKREG();

    while (1)
    {
        seg_display(val);
        val++;
        if (val > 99) val = 0;  // Limit counting from 0 to 99
        DrvSYS_Delay(500000);   // Delay for visibility
    }
}

============================================================================================================
//12. Using puTTy make a remote connection with SSH interface to raspberry pi and write a python program to blink a LED
import RPi.GPIO as GPIO
import time
# Use BCM pin numbering
GPIO.setmode(GPIO.BCM)
# Set the GPIO pin number where the LED is connected
LED_PIN = 17
# Set up the pin as output
GPIO.setup(LED_PIN, GPIO.OUT)
# Blink the LED
try:
while True:
GPIO.output(LED_PIN, GPIO.HIGH) # Turn on LED
time.sleep(1) # Wait 1 second
GPIO.output(LED_PIN, GPIO.LOW) # Turn off LED
time.sleep(1) # Wait 1 second
except KeyboardInterrupt:
print("Blinking stopped by user")
# Cleanup GPIO settings before exiting
finally:
GPIO.cleanup()


//9.Write a C program to enable External Interrupt pin to trigger interrupt on GPB15 and buzz.

#include <stdio.h>
#include "NUC1xx.h"
#include "Driver\DrvGPIO.h"
#include "Driver\DrvSYS.h"
#include "Driver\DrvUART.h"

// Interrupt Service Routine for External Interrupt 1 (connected to GPB15)
void EINT1_Handler(void) {
    GPIOB->ISRC = (1 << 15);          // Clear interrupt flag for GPB15
    DrvGPIO_ClrBit(E_GPB, 11);        // Turn ON Buzzer (active low)
    DrvSYS_Delay(100000);             // Delay to keep buzzer on briefly
    DrvGPIO_SetBit(E_GPB, 11);        // Turn OFF Buzzer
}

int main(void) {
    // Step 1: Unlock and configure system clock
    UNLOCKREG();
    DrvSYS_Open(48000000);            // Set system clock to 48MHz
    LOCKREG();

    // Step 2: Initialize Buzzer pin (GPB11) as output
    DrvGPIO_Open(E_GPB, 11, E_IO_OUTPUT);
    DrvGPIO_SetBit(E_GPB, 11);        // Turn buzzer OFF initially (active low)

    // Step 3: Initialize GPB15 as input for external interrupt
    DrvGPIO_Open(E_GPB, 15, E_IO_INPUT);

    // Step 4: Enable External Interrupt 1 (EINT1) on GPB15
    DrvGPIO_EnableEINT1(E_IO_BOTH_EDGE, E_MODE_EDGE, EINT1_Handler);

    while (1) {
        // Main loop: idle, wait for interrupt
    }
}

========================================================================================================================================================
========================================================================================================================================================
  Switch case     
        THUMB
        AREA |.text|, CODE, READONLY
        EXPORT __main

__main
        LDR     R0, =0
        CMP     R0, #3
        BHI     default_case

        MOVS    R2, #4
        MULS    R0, R2, R0
        LDR     R1, =BranchTable
        LDR     R2, [R1, R0]
        BX      R2

        ALIGN 4
BranchTable
        DCD     Dest0
        DCD     Dest1
        DCD     Dest2
        DCD     Dest3

default_case
        LDR     R0, =0
        B       stop

Dest0
        LDR     R0, =10
        B       stop

Dest1
        LDR     R0, =20
        B       stop

Dest2
        LDR     R0, =30
        B       stop

Dest3
        LDR     R0, =40
        B       stop

stop
        B       stop    ; Single infinite loop label

        END

